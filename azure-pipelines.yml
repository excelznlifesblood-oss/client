# .azure-pipelines.yml
trigger:
  branches:
    include:
      - main
      - feature/*

pr:
  branches:
    include: [ '*' ]

variables:
  DOTNET_SDK: '9.0.x'
  BUILD_CONFIGURATION: 'Release'
  BUILD_PLATFORM: 'x64'
  PLUGIN_PROJECT: 'MareSynchronos\ShoninSync.csproj'
  FEED_SOURCE_URL: 'https://excelzn.pkgs.visualstudio.com/000133ad-8b16-41ad-9d35-5040d0cd2c2f/_packaging/ShoninSync/nuget/v3/index.json'
  ZIP_REL_PATH: 'bin\x64\Release\ShoninSync\latest.zip'
  ICON_REL_PATH: 'MareSynchronos\images\icon.png'

stages:
- stage: Build
  displayName: Build Dalamud Plugin
  jobs:
  - job: build
    pool:
      vmImage: 'windows-latest'
    steps:
    - checkout: self
      clean: true

    - task: UseDotNet@2
      displayName: 'Use .NET SDK $(DOTNET_SDK)'
      inputs:
        packageType: 'sdk'
        version: '$(DOTNET_SDK)'

    # Auth for private feed restore
    - task: NuGetAuthenticate@1
      displayName: 'Authenticate to Azure Artifacts'

    # Add your Azure Artifacts source for restore
    - powershell: |
        $name = 'AzureArtifacts'
        $existing = & dotnet nuget list source | Select-String -Pattern "^\s*$name\s"
        if ($existing) { & dotnet nuget remove source $name | Out-Null }
        & dotnet nuget add source "$(FEED_SOURCE_URL)" `
          --name $name `
          --username "azdo" `
          --password "$(VSS_NUGET_ACCESSTOKEN)" `
          --store-password-in-clear-text | Out-Null
        & dotnet nuget list source
      displayName: 'Configure NuGet source for private feed'
      env:
        VSS_NUGET_ACCESSTOKEN: $(VSS_NUGET_ACCESSTOKEN)

    - script: dotnet restore "$(PLUGIN_PROJECT)"
      displayName: 'Restore'

    # >>> Install Dalamud to the expected dev path
    - powershell: |
        $ErrorActionPreference = 'Stop'

        $appData = [Environment]::GetFolderPath('ApplicationData')  # C:\Users\VssAdministrator\AppData\Roaming
        $devDir  = Join-Path $appData 'XIVLauncher\addon\Hooks\dev'
        New-Item -ItemType Directory -Force -Path $devDir | Out-Null

        # Prefer release; fall back to staging if needed
        $releaseUrl = 'https://goatcorp.github.io/dalamud-distrib/latest.zip'
        $stgUrl     = 'https://goatcorp.github.io/dalamud-distrib/stg/latest.zip'

        $zipPath = Join-Path $env:TEMP 'dalamud_latest.zip'

        function Get-And-Extract($url) {
          Write-Host "Downloading Dalamud from $url ..."
          Invoke-WebRequest -Uri $url -OutFile $zipPath
          Write-Host "Extracting to $devDir ..."
          Expand-Archive -Path $zipPath -DestinationPath $devDir -Force
          Remove-Item $zipPath -Force -ErrorAction SilentlyContinue
        }

        try {
          Get-And-Extract $releaseUrl
        } catch {
          Write-Warning "Release channel download failed: $($_.Exception.Message) â€” trying staging channel..."
          Get-And-Extract $stgUrl
        }

        # sanity check
        $dll = Get-ChildItem -Path $devDir -Recurse -Filter 'Dalamud.dll' -ErrorAction SilentlyContinue | Select-Object -First 1
        if (-not $dll) { throw "Dalamud.dll not found after extraction to $devDir" }
        Write-Host "Dalamud installed to $devDir (found $($dll.FullName))"
      displayName: 'Install Dalamud to %APPDATA%\XIVLauncher\addon\Hooks\dev'
    - script: >
        dotnet build "$(PLUGIN_PROJECT)"
        --configuration $(BUILD_CONFIGURATION)
        /p:Platform=$(BUILD_PLATFORM)
        /p:ContinuousIntegrationBuild=true
        --no-restore
      displayName: 'Build (Release x64)'

    # Collect ZIP + icon into a single artifact folder
    - powershell: |
        $projPath = "$(PLUGIN_PROJECT)"
        if (-not (Test-Path $projPath)) { throw "PLUGIN_PROJECT not found: $projPath" }
        $projDir = Split-Path -Path $projPath -Parent

        $zipAbs  = Join-Path $projDir "$(ZIP_REL_PATH)"
        if (-not (Test-Path $zipAbs)) { throw "ZIP not found at expected location: $zipAbs" }

        $iconAbs = Join-Path "$(Build.SourcesDirectory)" "$(ICON_REL_PATH)"
        if (-not (Test-Path $iconAbs)) { throw "Icon not found at: $iconAbs" }

        $out = "$(Build.ArtifactStagingDirectory)\out"
        New-Item -ItemType Directory -Force -Path $out | Out-Null
        Copy-Item -LiteralPath $zipAbs  -Destination (Join-Path $out 'latest.zip') -Force
        Copy-Item -LiteralPath $iconAbs -Destination (Join-Path $out 'icon.png') -Force

        Write-Host "Staged files:"
        Get-ChildItem $out | Format-Table Name,Length
      displayName: 'Stage ZIP + icon'

    - task: PublishPipelineArtifact@1
      displayName: 'Publish pipeline artifact: plugin'
      inputs:
        targetPath: '$(Build.ArtifactStagingDirectory)/out'   # folder with latest.zip + icon.png
        artifact: 'plugin'

- stage: Release
  displayName: Release to GitHub + Update Repo
  dependsOn: Build
  condition: and(succeeded(), ne(variables['Build.Reason'], 'PullRequest'))
  jobs:
  - job: github_release
    displayName: Create GitHub Release + Update plogonmaster.json
    pool:
      vmImage: 'windows-latest'
    variables:
      PLUGIN_GH_OWNER: 'excelznlifesblood-oss'
      PLUGIN_GH_REPO:  'client'
      TARGET_REPO_OWNER: 'excelznlifesblood-oss'
      TARGET_REPO_NAME:  'repo'
      TARGET_REPO_BRANCH: 'main'
      TARGET_FILE_PATH:   'plogonmaster.json'
      COMMIT_MESSAGE:     'chore: ShoninSync v$(PLUGIN_VERSION)'
    steps:
    - download: current
      displayName: 'Download artifact: plugin'
      artifact: plugin

    # Locate files (sets ZIP_PATH, ICON_PATH)
    - task: PowerShell@2
      displayName: 'Locate latest.zip + icon.png'
      inputs:
        targetType: inline
        script: |
          $ErrorActionPreference = 'Stop'
          $base = "$(Pipeline.Workspace)\plugin"
          if (-not (Test-Path $base)) { throw "Artifact base not found: $base" }
          $zip  = Get-ChildItem -Path $base -Recurse -Filter 'latest.zip' -ErrorAction SilentlyContinue | Select-Object -First 1
          $icon = Get-ChildItem -Path $base -Recurse -Filter 'icon.png'   -ErrorAction SilentlyContinue | Select-Object -First 1
          if (-not $zip)  { throw "Could not find latest.zip under $base" }
          if (-not $icon) { throw "Could not find icon.png under $base" }
          Write-Host "##vso[task.setvariable variable=ZIP_PATH]$($zip.FullName)"
          Write-Host "##vso[task.setvariable variable=ICON_PATH]$($icon.FullName)"

    # Detect version from ShoninSync.json inside the zip (sets PLUGIN_VERSION)
    - task: PowerShell@2
      displayName: 'Detect plugin version (ShoninSync.json)'
      inputs:
        targetType: inline
        script: |
          $ErrorActionPreference = 'Stop'
          Add-Type -AssemblyName System.IO.Compression.FileSystem
          $zipPath = "$(ZIP_PATH)"
          if (-not (Test-Path $zipPath)) { throw "ZIP not found: $zipPath" }
          $entryName = 'ShoninSync.json'
          $zip = [System.IO.Compression.ZipFile]::OpenRead($zipPath)
          try {
            $entry = $zip.Entries | Where-Object { $_.FullName -match '(^|/)' + [regex]::Escape($entryName) + '$' } | Select-Object -First 1
            if (-not $entry) { throw "Entry '$entryName' not found inside $zipPath" }
            $sr = New-Object System.IO.StreamReader($entry.Open(), [Text.Encoding]::UTF8)
            try { $json = $sr.ReadToEnd() } finally { $sr.Dispose() }
            $obj = $json | ConvertFrom-Json
            $ver = $obj.AssemblyVersion
            if ([string]::IsNullOrWhiteSpace($ver)) { throw "AssemblyVersion not found in $entryName" }
          } finally { $zip.Dispose() }
          Write-Host "##vso[task.setvariable variable=PLUGIN_VERSION]$ver"

    # Create (or reuse) GitHub Release and upload assets
    - task: PowerShell@2
      displayName: 'GitHub Release: v$(PLUGIN_VERSION) with assets'
      env:
        GITHUB_PAT: $(GITHUB_PAT)   # add as a secret pipeline variable
      inputs:
        targetType: inline
        script: |
          $ErrorActionPreference = 'Stop'
          $owner = "$(PLUGIN_GH_OWNER)"; $repo = "$(PLUGIN_GH_REPO)"
          $tag = "v$(PLUGIN_VERSION)"
          $targetCommitish = "$(Build.SourceVersion)"  # or your default branch
          $zipPath = "$(ZIP_PATH)"; $iconPath = "$(ICON_PATH)"
          $hdr = @{
            "Accept"="application/vnd.github+json"; "Authorization"="Bearer $env:GITHUB_PAT";
            "X-GitHub-Api-Version"="2022-11-28"; "User-Agent"="azure-devops-yaml"
          }
          $base = "https://api.github.com/repos/$owner/$repo/releases"
          try { $rel = Invoke-RestMethod -Uri "$base/tags/$tag" -Headers $hdr -Method GET }
          catch { if ($_.Exception.Response.StatusCode.Value__ -ne 404) { throw }
                  $body = @{ tag_name=$tag; name="ShoninSync $tag"; target_commitish=$targetCommitish; draft=$false; prerelease=$false } | ConvertTo-Json
                  $rel = Invoke-RestMethod -Uri $base -Headers $hdr -Method POST -Body $body }
          $rid = $rel.id
          $assets = Invoke-RestMethod -Uri "$base/$rid/assets" -Headers $hdr -Method GET
          foreach ($n in @("latest.zip","icon.png")) {
            $existing = $assets | Where-Object name -eq $n
            if ($existing) { Invoke-RestMethod -Uri "https://api.github.com/repos/$owner/$repo/releases/assets/$($existing.id)" -Headers $hdr -Method DELETE | Out-Null }
          }
          function Upload-Asset($path,$contentType) {
            if (-not (Test-Path $path)) { throw "Asset not found: $path" }
            $name = [IO.Path]::GetFileName($path)
            $uploadUrl = $rel.upload_url -replace "\{\?name,label\}$", "?name=$([uri]::EscapeDataString($name))"
            Invoke-WebRequest -Uri $uploadUrl -Headers $hdr -Method POST -InFile $path -ContentType $contentType | Out-Null
          }
          Upload-Asset $zipPath "application/zip"
          Upload-Asset $iconPath "image/png"

    # Update plogonmaster.json in the other repo
    - task: PowerShell@2
      displayName: 'Update plogonmaster.json in excelznlifesblood-oss/repo'
      env:
        GITHUB_PAT: $(GITHUB_PAT)
      inputs:
        targetType: inline
        script: |
         $ErrorActionPreference = 'Stop'

          # --- Auth & headers ---
          if (-not $env:GITHUB_PAT -or [string]::IsNullOrWhiteSpace($env:GITHUB_PAT)) {
            throw "GITHUB_PAT is missing/empty."
          }
          $hdr = @{
            "Accept"               = "application/vnd.github+json"
            "Authorization"        = "Bearer $($env:GITHUB_PAT)"
            "X-GitHub-Api-Version" = "2022-11-28"
            "User-Agent"           = "azure-devops-release"
          }

          # --- Inputs (trim & normalize) ---
          $owner2  = "$(TARGET_REPO_OWNER)".Trim()
          $repo2   = "$(TARGET_REPO_NAME)".Trim()
          $branch2 = "$(TARGET_REPO_BRANCH)".Trim()
          $path2   = "$(TARGET_FILE_PATH)".Trim()      # e.g. plogonmaster.json
          $ver     = "$(PLUGIN_VERSION)".Trim()

          if ([string]::IsNullOrWhiteSpace($owner2))  { throw "TARGET_REPO_OWNER is empty." }
          if ([string]::IsNullOrWhiteSpace($repo2))   { throw "TARGET_REPO_NAME is empty." }
          if ([string]::IsNullOrWhiteSpace($branch2)) { throw "TARGET_REPO_BRANCH is empty." }
          if ([string]::IsNullOrWhiteSpace($path2))   { throw "TARGET_FILE_PATH is empty." }
          if ([string]::IsNullOrWhiteSpace($ver))     { throw "PLUGIN_VERSION is empty." }

          # Normalize path to URL form (no leading slash, forward slashes only)
          $path2 = $path2.TrimStart('/','\').Replace('\','/')

          # Build contents URL safely
          $ub = New-Object System.UriBuilder("https://api.github.com")
          $ub.Path  = ("repos/{0}/{1}/contents/{2}" -f $owner2, $repo2, $path2)
          $ub.Query = ("ref={0}" -f [Uri]::EscapeDataString($branch2))
          $contentsGetUri = $ub.Uri.AbsoluteUri
          Write-Host "GET $contentsGetUri"

          # Release asset URLs
          $ownerRel = "$(PLUGIN_GH_OWNER)".Trim()
          $repoRel  = "$(PLUGIN_GH_REPO)".Trim()
          $relBase  = "https://github.com/$ownerRel/$repoRel/releases/download/v$ver"
          $iconUrl  = "$relBase/icon.png"
          $zipUrl   = "$relBase/latest.zip"

          # --- 1) GET current file (sha + content) ---
          $curr  = Invoke-RestMethod -Uri $contentsGetUri -Headers $hdr -Method GET
          $sha   = $curr.sha
          $rawB64 = ($curr.content -replace '\s','')      # strip whitespace/newlines from base64
          $bytes  = [Convert]::FromBase64String($rawB64)
          $text   = [Text.Encoding]::UTF8.GetString($bytes)

          # --- 2) Parse JSON and ensure it is an ARRAY ---
          $data = $text | ConvertFrom-Json
          if ($data -isnot [System.Array]) {
            throw "Expected top-level JSON array in $path2; refusing to write a non-array and break Dalamud format."
          }
          if ($data.Count -lt 1) { throw "Top-level array is empty in $path2." }

          # Find the item to update (by InternalName)
          $target = $null
          foreach ($it in $data) { if ($it.InternalName -eq 'ShoninSync') { $target = $it; break } }
          if (-not $target) { throw "No entry with InternalName 'ShoninSync' found in $path2." }

          # Update ONLY the target object
          $target.AssemblyVersion     = $ver
          $target.IconUrl             = $iconUrl
          $target.DownloadLinkInstall = $zipUrl

          # Serialize the ENTIRE ARRAY back
          $newJson = $data | ConvertTo-Json -Depth 100

          # Optional: skip commit if no change
          if ($newJson -eq $text) {
            Write-Host "No changes to commit in $path2"
            return
          }

          $newB64 = [Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes($newJson))

          # --- 3) PUT updated content back (same path/branch, include sha) ---
          $ubPut = New-Object System.UriBuilder("https://api.github.com")
          $ubPut.Path = ("repos/{0}/{1}/contents/{2}" -f $owner2, $repo2, $path2)
          $putUri = $ubPut.Uri.AbsoluteUri

          $body = @{
            message = "$(COMMIT_MESSAGE)"
            content = $newB64
            branch  = $branch2
            sha     = $sha
          } | ConvertTo-Json

          Write-Host "PUT $putUri (branch=$branch2)"
          $update = Invoke-RestMethod -Uri $putUri -Headers $hdr -Method PUT -Body $body
          Write-Host ("Updated {0} on {1} (commit {2})" -f $path2, $branch2, $update.commit.sha.Substring(0,7))

